/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of Qt Creator.
**
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 as published by the Free Software
** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
****************************************************************************/

#include <QDebug>
#include <QDir>
#include <QCoreApplication>

#include <QStringList>
#include <QTextBlock>
#include <QTextCursor>
#include <QTextDocument>

#include <cplusplus/Control.h>
#include <cplusplus/Parser.h>
#include <cplusplus/AST.h>
#include <cplusplus/ASTVisitor.h>
#include <cplusplus/Symbols.h>
#include <cplusplus/CoreTypes.h>
#include <cplusplus/Literals.h>
#include <cplusplus/CppDocument.h>
#include <cplusplus/Overview.h>
#include <cplusplus/Names.h>
#include <cplusplus/Scope.h>
#include <cplusplus/BackwardsScanner.h>

#include <utils/algorithm.h>
#include <utils/changeset.h>
#include <iostream>
#include <cstdlib>
using namespace CPlusPlus;


#define VENDOR_NAMESPACE "Service"
#define MWB_NAMESPACE VENDOR_NAMESPACE "\\Mwb"
#define GRT_NAMESPACE MWB_NAMESPACE "\\Grt"

#define GRT_H "structs.h"
#define AST_CPP "AST.cpp"

#define ASTVisit_cpp "ASTVisit.cpp"
#define ASTVisitor_h "ASTVisitor.h"
#define ASTMatch0_cpp "ASTMatch0.cpp"
#define ASTMatcher_cpp "ASTMatcher.cpp"
#define ASTMatcher_h "ASTMatcher.h"
#define ASTClone_cpp "ASTClone.cpp"
#define ASTPatternBuilder_h "ASTPatternBuilder.h"
#define ASTfwd_h "ASTfwd.h"

#define NS_cpp "Php"
#define NS "PHP"


static const char copyrightHeader[] =
"// Copyright (c) 2008 Roberto Raggi <roberto.raggi@gmail.com>\n"
"//\n"
"// Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"// of this software and associated documentation files (the \"Software\"), to deal\n"
"// in the Software without restriction, including without limitation the rights\n"
"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"// copies of the Software, and to permit persons to whom the Software is\n"
"// furnished to do so, subject to the following conditions:\n"
"//\n"
"// The above copyright notice and this permission notice shall be included in\n"
"// all copies or substantial portions of the Software.\n"
"//\n"
"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"// THE SOFTWARE.\n"
;

static const char generatedHeader[] =
"\n"
"//\n"
"//  W A R N I N G\n"
"//  -------------\n"
"//\n"
"// This file is automatically generated by \"mwb-update-frontend\".\n"
"// Changes will be lost.\n"
"//\n"
"\n"
;

static QIODevice::OpenMode openFlags = QIODevice::WriteOnly | QIODevice::Text;

static void closeAndPrintFilePath(QFile &file)
{
    if (file.isOpen()) {
        const QString filePath = QFileInfo(file).canonicalFilePath();
        std::cout << " -- " << QDir::toNativeSeparators(filePath).toLatin1().constData() << std::endl;
        file.close();
    }
}

class TypeGenerator
{
public:
    TypeGenerator() : name(""){}

    QString name;// int|string|objet|array
    QString struct_name;
};

class PropertyGenerator
{
public:
    PropertyGenerator() : name(""), type() {}
    QString name;
    TypeGenerator type;
};

class ClassGenerator
{
public:
    ClassGenerator() {}

    QString name;
    QString extends;
    QList<QString *> uses;
    QList<PropertyGenerator *> properties;
};


static Document::Ptr GRT_h_document;

class GrtStructVisitor: protected ASTVisitor
{
public:
    GrtStructVisitor(Document::Ptr doc, QTextDocument *document)
        : ASTVisitor(doc->translationUnit()), document(document)
    {
    }

    QList<ClassGenerator *> operator()(AST *ast)
    {
        accept(ast);
        
        return _classesGenerator;
    }

protected:
//  boost::signals2::signal<void()> _signal_contentChanged;
//class GRT_STRUCTS_DB_PUBLIC db_ForeignKey : public GrtNamedObject {


    virtual bool visit(SimpleNameAST *ast)
    {
        if (!_propertyGenerator) return true;

        _propertyGenerator->type.name = ast->name->identifier()->chars();

        return true;
    }
    
    virtual bool visit(TypeIdAST *ast)
    {
        if (!_classGenerator) return true;

        for (SpecifierListAST *it = ast->type_specifier_list; it; it = it->next) {
            NamedTypeSpecifierAST *contentType = it->value->asNamedTypeSpecifier();
            if (contentType) {
                if (contentType->name->asSimpleName()) {
                    /*
                    propStructType = QString("<");
                    propStructType.append(contentType->name->asSimpleName()->name->identifier()->chars());
                    propStructType.append(">");
                    */
                    //qDebug() << "class " <<  contentType->name->asSimpleName()->name->identifier()->chars() << " extends ?";
                }
            }
        }
        
        return true;
    }

    virtual bool visit(QualifiedNameAST *ast)
    {
        if (!_classGenerator) return true;
        if (! (startProtectedDeclaration && !endDeclaration) ) return false;
        if (!_propertyGenerator ) return false;

        const char *name_or_ns = 0;
        for ( NestedNameSpecifierListAST* it = ast->nested_name_specifier_list; it; it = it->next) {
            if (NestedNameSpecifierAST*nameSpecifier = it->value->asNestedNameSpecifier()) {
                name_or_ns = nameSpecifier->class_or_namespace_name->name->identifier()->chars();
            }
        }
        
        if (TemplateIdAST *templateId = ast->unqualified_name->asTemplateId()) {
            if (name_or_ns) {
                _propertyGenerator->type.name += name_or_ns;
                _propertyGenerator->type.name += "::";
            }
            _propertyGenerator->type.name += templateId->name->identifier()->chars();
            for ( ExpressionListAST* it = templateId->template_argument_list; it; it = it->next) {
                if (TypeIdAST *propTypeId = it->value->asTypeId()) {
                    //visit(propTypeId);
                    _propertyGenerator->type.name += "<";
                    if (NamedTypeSpecifierAST* struct_name = propTypeId->type_specifier_list->value->asNamedTypeSpecifier()) {
                        _propertyGenerator->type.name += struct_name->name->name->identifier()->chars();
                    }
                    _propertyGenerator->type.name += ">";
                }
            }
        } else if (SimpleNameAST *simpleName = ast->unqualified_name->asSimpleName()) {
            if (name_or_ns) {
                _propertyGenerator->type.name += name_or_ns;
                _propertyGenerator->type.name += "::";
                _propertyGenerator->type.name += simpleName->name->identifier()->chars();
            }
        } else {
            //propStructType = QString("");
        }

        return true;
    }

    virtual bool visit(NamedTypeSpecifierAST *ast)
    {
        //if (!_classGenerator) return true;
        //if (! (startProtectedDeclaration && !endDeclaration) ) return true;
        if (!_propertyGenerator) return true;

        if (QualifiedNameAST *qName = ast->name->asQualifiedName()) {
            visit(qName);
        } else {
            if (SimpleNameAST *simpleName = ast->name->asSimpleName()) {
                visit(simpleName);
            }
        }

        return true;
    }

    virtual bool visit(AccessDeclarationAST *ast)
    {
        if (!_classGenerator) return true;// Used ?

        if (endDeclaration) {
            return true;
        }
        if (startProtectedDeclaration) {
            if (tokenKind(ast->access_specifier_token) == T_PRIVATE) {
                endDeclaration = true;
            }
        }
        if (tokenKind(ast->access_specifier_token) == T_PROTECTED) {
            startProtectedDeclaration = true;
            /*
            SimpleDeclarationAST *simpleDecl = ast->asSimpleDeclaration();
            if (simpleDecl) {
                visit(simpleDecl);
            }
            */
        }

        return true;
    }
    virtual bool visit(BaseSpecifierAST *ast)
    {
        if (!_classGenerator) return true;// Used ?
        
        const char *c_baseName = ast->name->name->identifier()->chars();
        _classGenerator->extends = QString(c_baseName);

        return false;
    }

    virtual bool visit(ClassSpecifierAST *ast)
    {
        _classGenerator = nullptr;
        
        Class *klass = ast->symbol;
        Q_ASSERT(klass != 0);

        const QString className = oo(klass->name());
        startProtectedDeclaration = false;
        endDeclaration = false;

        //if (className.startsWith(QString("Grt"))) {
        if (className.startsWith(prefix)) {
            if (className == QString("Grt")) {
            } else {
                _classGenerator = new ClassGenerator();
                _classGenerator->name = className;
                for (BaseSpecifierListAST *it = ast->base_clause_list; it; it = it->next) {
                    visit(it->value->asBaseSpecifier());
                }
                
                _classesGenerator.append(_classGenerator);
                
                for (DeclarationListAST *it = ast->member_specifier_list; it; it = it->next) {
                    visit(it->value->asDeclaration());
                }
                
                return true;
            }
        }

        return false;
    }
    
    virtual bool visit(SimpleDeclarationAST *ast)
    {
        if (!_classGenerator) return true;
        if (!startProtectedDeclaration) return true;

        for ( DeclaratorListAST* it = ast->declarator_list; it; it = it->next) {
            DeclaratorAST *decl =  it->value->asDeclarator();
            if (decl) {
                DeclaratorIdAST *declId =  decl->core_declarator->asDeclaratorId();
                if (declId) {
                    SimpleNameAST *idName = declId->name->asSimpleName();
                    if (idName) {
                        qDebug() << "     " << idName->name->identifier()->chars();
                    }
                    //qDebug() << "    * " << propType << propStructType.toStdString().data() << " : " << idName->name->identifier()->chars();
                }
            }
        }
        for (SpecifierListAST *it = ast->decl_specifier_list; it; it = it->next) {
            SpecifierAST *specifier = it->value->asSpecifier();
            /*
            NamedTypeSpecifierAST *namedTypeSpecifier = specifier->asNamedTypeSpecifier();
            if (specifier) {
                visit(specifier);
            }
            */
        }

        // ast->as
        // 
        return true;
    }
    
    /*
    virtual bool visit(ElaboratedTypeSpecifierAST *ast)
    {
        ElaboratedTypeSpecifierAST *specifier =  it->value->asElaboratedTypeSpecifier();
        if (specifier) {
            visit(specifier);
        }
        return true;
    }
    */

    virtual bool visit(DeclaratorAST *ast)
    {
        if (!_propertyGenerator)return true;
        
        if (DeclaratorIdAST* id = ast->core_declarator->asDeclaratorId())  {
            _propertyGenerator->name += id->name->name->identifier()->chars();
        }

        return true;
    }

    virtual bool visit(DeclarationAST *ast)
    {
        if (AccessDeclarationAST *astNode = ast->asAccessDeclaration()) {
            visit(astNode);
            return true;
        }
        if (_classGenerator && (startProtectedDeclaration&&!endDeclaration)) {
            _propertyGenerator = new PropertyGenerator();
        }
        if (SimpleDeclarationAST *astNode = ast->asSimpleDeclaration()) {
            for ( DeclaratorListAST* it = astNode->declarator_list; it; it = it->next) {
                if (_propertyGenerator)
                    if (DeclaratorAST *declarator =  it->value->asDeclarator()) {
                        visit(declarator);
                    }
            }
            for ( SpecifierListAST* it = astNode->decl_specifier_list; it; it = it->next) {
                if (ClassSpecifierAST *specifier =  it->value->asClassSpecifier()) {
                    visit(specifier);
                }
                if (NamedTypeSpecifierAST *specifier =  it->value->asNamedTypeSpecifier()) {
                    //_propertyGenerator->type
                    visit(specifier);
                }
                /*
                ElaboratedTypeSpecifierAST *specifier =  it->value->asElaboratedTypeSpecifier();
                if (specifier) {
                    visit(specifier);
                }
                */

            }
        }
        if (/**/_classGenerator && (startProtectedDeclaration&&!endDeclaration) &&/**/ _propertyGenerator) {
            _classGenerator->properties.append(_propertyGenerator);
            _propertyGenerator = 0;
        }

        // NamespaceAST -> DeclarationAST -> AST
        // EmptyDeclarationAST -> DeclarationAST -> AST
        // AccessDeclarationAST -> DeclarationAST -> AST
        // SimpleDeclarationAST -> DeclarationAST -> AST
        // FunctionDefinitionAST -> DeclarationAST -> AST
        return true;
    }

    virtual bool visit(TranslationUnitAST *ast)
    {
        for (DeclarationListAST *it = ast->declaration_list; it; it = it->next) {
            visit(it->value->asDeclaration());
        }
        return false;
    }


private:
    QTextDocument *document;
    Overview oo;
    
    QList<ClassGenerator *> _classesGenerator;
    ClassGenerator *_classGenerator = nullptr;
    PropertyGenerator* _propertyGenerator = nullptr;

    bool startProtectedDeclaration = false;
    bool endDeclaration = false;
    
    bool startQualifiedName = false;
    bool endQualifiedName = false;
public:
    QString prefix;
};



QStringList inspectGRT_H(const Snapshot &snapshot, const QDir &mwbDir, const QString &dumpersFile, QString& prefixClass)
{
    QStringList astDerivedClasses;

    QDir mwbDataDir(mwbDir.absolutePath());
    mwbDataDir.cd("data/6.3/");
    //QFileInfo fileGRT_h(mwbDataDir, QString(GRT_H));
    //QFileInfo fileGRT_h(mwbDataDir, QString("structs.db.h"));
    QFileInfo fileGRT_h(mwbDataDir, dumpersFile);
    Q_ASSERT(fileGRT_h.exists());

    const QString fileName = fileGRT_h.absoluteFilePath();
    qDebug() << fileName;

    QFile file(fileName);
    if (! file.open(QFile::ReadOnly))
        return astDerivedClasses;

    const QByteArray source = file.readAll();
    file.close();


    QTextDocument document;
    document.setPlainText(QString::fromUtf8(source));
    
    
    GRT_h_document = snapshot.preprocessedDocument(source, fileName);
    GRT_h_document->check();

    GrtStructVisitor process(GRT_h_document, &document);
    process.prefix = prefixClass;
    
    QList<ClassGenerator*> classesGenerator = process(GRT_h_document->translationUnit()->ast());
    
    QString sourceCode;

    QTextDocument fileGenerator;
    
    sourceCode = "<?php\n\n";

    sourceCode += "return [\n";
    
    foreach (ClassGenerator *klass, classesGenerator) {

        sourceCode += "\t" "'";
        sourceCode += klass->name.toStdString().c_str();
        sourceCode += "' => [\n";
        
        ///qDebug() << klass->name.toStdString().c_str() << "extends" << klass->extends.toStdString().c_str();
        sourceCode += "\t\t";
        sourceCode += "'extends' => '";
        sourceCode += klass->extends.toStdString().c_str();
        sourceCode += "',\n";
        
        sourceCode += "\t\t" "'properties' => [\n";
        foreach (PropertyGenerator *property, klass->properties) {
            ///qDebug() << "    " << property->type.name.toStdString().c_str() << " $" << property->name.toStdString().c_str();
            sourceCode += "\t\t\t" "'";
            sourceCode += property->name.toStdString().c_str();
            sourceCode += "' => '";
            sourceCode += property->type.name.toStdString().c_str();
            sourceCode += "',\n";
        }
        sourceCode += "\t\t],\n";
        
        sourceCode += "\t],\n";
    }
    
    sourceCode += "];\n";
    
    fileGenerator.setPlainText(sourceCode);
     
    QDir mwbOutDir(mwbDir.absolutePath());
    mwbOutDir.cd("out/6.3");

    QFileInfo outFileGRT_h(mwbOutDir, dumpersFile+".php");
    const QString outGrtFilename = outFileGRT_h.absoluteFilePath();
    QFile outGrtFile(outGrtFilename);

    if (outGrtFile.open(openFlags)) {
        QTextStream out(&outGrtFile);
        out << fileGenerator.toPlainText();
        closeAndPrintFilePath(outGrtFile);
    }



    /*
    Overview oo;
    

    QDir mwbOutDir(mwbDir.absolutePath());
    mwbOutDir.cd("out");
    QFileInfo outFileAST_h(mwbOutDir, QString(GRT_H));
    const QString outFileName = outFileAST_h.absoluteFilePath();
    QFile outFile(outFileName);

    if (outFile.open(openFlags)) {
        QTextStream out(&outFile);
        out << document.toPlainText();
        closeAndPrintFilePath(outFile);
    }
    */
    
    
    
    /*
    Accept0CG cg(mwbDir, GRT_h_document->translationUnit());
    cg(GRT_h_document->translationUnit()->ast());
    const QList<QByteArray> astClasses = cg.classes();

    Match0CG cg2(mwbDir, GRT_h_document->translationUnit());
    cg2(GRT_h_document->translationUnit()->ast());

    MatcherCPPCG cg3(mwbDir, GRT_h_document->translationUnit());
    cg3(GRT_h_document->translationUnit()->ast());

    CloneCPPCG cg4(mwbDir, GRT_h_document->translationUnit());
    cg4(GRT_h_document->translationUnit()->ast());

    // review the generation of firstToken/lastToken() (use "public: // annotation" comment
    generateAST_cpp(snapshot, mwbDir);

    // review Accept0CG::visit to generate accept0() (//annotation ? )
    generateASTVisitor_H(snapshot, mwbDir, astClasses);
    generateASTMatcher_H(snapshot, mwbDir, astClasses);

    if (!dumpersFile.isEmpty())
        GenerateDumpers::go(dumpersFile, STRUCT_h_document->translationUnit());
    */

    return astDerivedClasses;
}


void printUsage()
{
    const QByteArray executable = QFileInfo(QCoreApplication::arguments().first()).fileName().toLatin1();
    std::cout << "Usage: " << executable.constData() << "\n"
              << "       " << executable.constData() << " <frontend-dir> <dumpers-file>"
              << "\n\n"
              << "Generate appropriate header and source files of the C++ frontend accordingly\n"
              << "to AST.h and print the paths of the written files. Run this tool after\n"
              << "modifying AST.h."
              << "\n\n";
    const QString defaultpathPhpFrontend
        = QFileInfo(QString(PATH_MWB_FRONTEND)).canonicalFilePath();
    const QString defaultPathDumpersFile
        = QFileInfo(QString(PATH_DUMPERS_FILE)).canonicalFilePath();
    std::cout << "Default values:" << "\n"
              << "   frontend-dir: " << qPrintable(defaultpathPhpFrontend) << "\n"
              << "   dumpers-file: " << qPrintable(defaultPathDumpersFile) << "\n";
}


int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    QStringList args = app.arguments();
    args.removeFirst();
    
    QString pathMwbFrontend = QString(PATH_MWB_FRONTEND);
    QString pathDumpersFile = QString(PATH_DUMPERS_FILE);

    std::cout << "Starting generating mwb model" << std::endl;
    
    const bool helpRequested = args.contains(QString("-h"))
        || args.contains(QString("-help"));
    if (args.count() == 1 || args.count() >= 3 || helpRequested) {
        printUsage();
        return helpRequested ? EXIT_SUCCESS : EXIT_FAILURE;
    } else if (args.count() == 2) {
        pathMwbFrontend = args.at(0);
        pathDumpersFile = args.at(1);
    }

    QDir mwbDir(pathMwbFrontend);
    if (!QFile::exists(pathMwbFrontend)) {
        std::cerr << "Error: Directory \"" << qPrintable(mwbDir.absolutePath())
                  << "\" does not exist." << std::endl;
        return EXIT_FAILURE;
    }
    
    QDir mwbDataDir(pathMwbFrontend);
    mwbDataDir.cd("data");
    if (!QFileInfo(mwbDataDir, QString(GRT_H)).exists()) {
        std::cerr << "Error: Cannot find grt.h in \"" << qPrintable(mwbDataDir.absolutePath())
                  << "\"." << std::endl;
        return EXIT_FAILURE;
    }
    
    Snapshot snapshot;
    QStringList astDerivedClasses;
    
    /* 6.3
    */
    const char* filepaths[][2] = {
        //{"",                          "grt.h"},
        
        {"db_",                        "structs.db.h"},
        {"app_",                       "structs.app.h"},
        {"db_mgmt_",                   "structs.db.mgmt.h"},
        {"db_migration_",              "structs.db.migration.h"},
        {"db_mssql_",                  "structs.db.mssql.h"},
        {"db_mysql_",                  "structs.db.mysql.h"},
        {"db_query_",                  "structs.db.query.h"},
        {"db_sybase_",                 "structs.db.sybase.h"},
        {"eer_",                       "structs.eer.h"},
        {"Grt",                          "structs.h"},
        {"meta_",                      "structs.meta.h"},
        {"model_",                     "structs.model.h"},
        {"ui_",                        "structs.ui.h"},
        {"workbench_",                 "structs.workbench.h"},
        {"workbench_logical_",         "structs.workbench.logical.h"},
        {"workbench_model_",           "structs.workbench.model.h"},
        {"workbench_model_reporting_", "structs.workbench.model.reporting.h"},
        {"workbench_physical_",        "structs.workbench.physical.h"},
        
        //{"wrapper_",                   "structs.wrapper.h"},
        //    {"parser_",                   "structs.wrapper.h"},
        //    {"mforms_",                   "structs.wrapper.h"},
        //    {"grt_",                      "structs.wrapper.h"},
        {0, 0},
    };

    /* 8.0
    const char* filepaths[][2] = {
        {"app_",                       "structs.app.h"},
        {"db_",                        "structs.db.h"},
        {"db_mgmt_",                   "structs.db.mgmt.h"},
        {"db_migration_",              "structs.db.migration.h"},
        {"db_mssql",                   "structs.db.mssql.h"},
        {"db_mysql_",                  "structs.db.mysql.h"},
        {"db_query_",                  "structs.db.query.h"},
        {"db_sybase_",                 "structs.db.sybase.h"},
        {"eer_",                       "structs.eer.h"},
        {"Grt",                        "structs.h"},
        {"meta_",                      "structs.meta.h"},
        {"model_",                     "structs.model.h"},
        {"ui_",                        "structs.ui.h"},
        {"workbench_",                 "structs.workbench.h"},
        {"workbench_logical_",         "structs.workbench.logical.h"},
        {"workbench_model_",           "structs.workbench.model.h"},
        {"workbench_model_reporting_", "structs.workbench.model.reporting.h"},
        {"workbench_physical_",        "structs.workbench.physical.h"},
        //{"wrapper_",                        "structs.wrapper.h"},
        {0, 0},
    };
    */

    QString prefix;

    for(int i=0; filepaths[i][1]!=0; i++) {
        prefix = filepaths[i][0];
        pathDumpersFile = filepaths[i][1];
        /*
        if (!QFile::exists(pathDumpersFile)) {
            std::cerr << "Error: File \"" << qPrintable(pathDumpersFile)
                      << "\" does not exist." << std::endl;
            return EXIT_FAILURE;
        }
        */

        inspectGRT_H(snapshot, mwbDir, pathDumpersFile, prefix);
    }

    
    /*
    //review FindASTForwards to create cursor after all
    generateASTFwd_h(snapshot, phpDir, astDerivedClasses);
    
    //it use match0()
    generateASTPatternBuilder_h(phpDir);
    */

    return EXIT_SUCCESS;
}
